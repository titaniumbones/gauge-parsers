* River Gauge Client

This is a small library to fetch and parse API responses from river gauges in Ontario. The library provides the following:

- a *dictionary* that matches river gauge types to parsing functions. So far the only ones I know about are [[https://wateroffice.ec.gc.ca/report/real_time_e.html?stn=02HB029&mode=Graph][Ontario Water Offic Gauges]], [[https://apps.grandriver.ca/waterdata/kiwischarts/rf_uppergrand.aspx][Grand River conservation Area Gauges]], and [[https://cvc.ca/watershed-science/watershed-monitoring/real-time-monitoring/west-credit-river-belfountain-conservation-area/][Credit Valley conservation Cauges]]. GRCA and CVC gauges both use the WISKI/KIWIS/KISTER water gauge data management platform, so their data sources are providedi  ithe same format. Wateroffice has a very similar but nonidentical format. CVC and GRCA unfortunately use distinct URL construction patterns.
- *get* and *parse* functions that *retrieve* and *process* API responses form the various endpoints and prepare them to be fed to a [[https://chartist-js.org][Chartist chart]].  These should take 

This should be as self-contained as possible, and each parser function should be a stable interface that provides datain a predictable format that chartist can use; should also be possible to meet the needs of other chart construction libraries, e.g. D3

Lots of TODOs here: 
- [ ] find more online gauges! I only have a small percentage of runnable rivers here. Check Boatwerks, and also these suggestions:
  - [ ] Cataract section of credit river
  - [ ] Humber River (find the gauge)
  - [ ] Moira
  - [ ] Claireville (??)
  - [ ] Hockley Valley (?)
  - [ ] Upper Black (??)
  - [ ] Skootamatta
  - [ ] Beaver
  - [ ] Ottawa River
- [ ] determine which of these gauges provide historical data in a different format from the real-time data, and figure out how to manage it.  e.g., wateroffice appears to store ~2 years of data in the json endpoint, after which it is available only in CSV format from a separate endpoint
- [ ] Figure out how to display auxiliary data simultaneously -- e.g., mean/median data from water office, rainfall data from CVC.
- [ ] Similarly: is there a way to capture rainfall info using other data sources, and add that in somehow? That last is a big ask.  But it should be possible to either link to windy for forecasts or to another service for historical data.  e.g., raw data for Ontario is [[https://climate.weather.gc.ca/historical_data/search_historic_data_stations_e.html?searchType=stnProv&timeframe=1&lstProvince=ON&optLimit=yearRange&StartYear=2016&EndYear=2019&Year=2019&Month=12&Day=3&selRowPerPage=100][available at this endpoint]], while [[https://climate.weather.gc.ca/radar/index_e.html?site=CASKR&year=2019&month=12&day=1&hour=00&minute=10&duration=2&image_type=PRECIPET_SNOW_WEATHEROFFICE][RADAR images can be picked up here]].  Links should be easy, I think. The images themselves are available at URLs like https://climate.weather.gc.ca/radar/image_e.html?time=201612011840&site=CASKR&image_type=PRECIPET_SNOW_WEATHEROFFICE, where the time value is ~YYYYMMDDHHmm~ in *UTC*
- [ ] correcting for time zone also important. I haven't inspected the data yet to be sure it's corrected for time zone.


#+NAME: gaugeparser
#+begin_src js :tangle gaugeParser.js

/* 

   RIVER GAUGE DEFINITIONS

*/
const streetsville = {
  "name": "Credit River at Streetsville",
  "gaugeType": "wateroffice",
  "gaugeID": "02HB029",
  "units": "cms",
  "lat":123.456,
  "long": -456.789,
  "directions": [[0,4.6,"bad"], [4.6,8,"shoulder"], [8,50,"good"],[50,100,"shoulder"]],
  "qualityPeaks": [ [0,"bad"], [85, "good"], [170, "bad"], [290, "bad"] ],
  "minHeight": 4.6
},
      irvine =   {
        "name": "Irvine",
        "gaugeType": "wateroffice",
        "gaugeID": "02GA005",
        "slug": "irvine",
        "units": "cms",
        "points":{ 
          "putin": [] ,
          "takeout": [] ,
          "takeout2": []
        },
        "directions": [[0,4.6,"bad"], [4.6,8,"shoulder"], [8,50,"good"],[50,100,"shoulder"]],
        "qualityPeaks": [ [0,"bad"], [85, "good"], [170, "bad"], [290, "bad"] ],
        "minHeight": 4.6
      },
      elora = {name: "Elora Gorge at Shand Dam",
               gaugeType: "grca",
               gaugeID: 'Shand Dam Discharge',
               "units": "cms",
               slug: "gorge",
               points: {},
               minHeight: 5,
               directions: [[0,4.6,"bad"], [4.6,8,"shoulder"], [8,50,"good"],[50,100,"shoulder"]],
              },
      upperCredit = {name: "Upper Credit River at Belfountain",
                     gaugeType: "cvc",
                     gaugeID: '14522010',
                     "units": "cms",
                     slug: "uppercredit",
                     points: {},
                     minHeight: 0.75,
                     directions: [[0,0.75,"bad"], [0.75, 0.78,"shoulder"], [0.78, 1.1,"good"],[1.1,100,"shoulder"]],
                    },
      rivers =[elora, streetsville, upperCredit, irvine];

/* DICTIONARY mapping gauge type to function */

// I think fn symbols are hoisted so should be ok here?
const gaugeDict = {
  cvc: processWiskiData,
  grca: processWiskiData,
  wateroffice: processWOData
}

/* TESTER for all gauge types */

function testGood (direction, spotMeta=streetsville) {
  let value = 'bad';
  spotMeta.directions
    .some( function (d)  {
      if ( (d[0] < direction) && ( direction < d[1])  ) {
        // console.log(d);
        value = d[2]; return; }
    });
  //console.log(value)
  return value
}


/*
 ,*
 ,* WISKI/KIWIS-based gauges (currently grca & cvc)
 ,* see notes for individual discrapncies
 ,* 
 ,*/


// for parsing grand river json data,
// see ~line 65 of https://apps.grandriver.ca/waterdata/kiwischarts/js/RF_Charts.js?v1.0
// accessed 2019-12-04
// also cf variable definitions in https://apps.grandriver.ca/waterdata/kiwischarts/rf_uppergrand.aspx
// doesn't appear to accept a date parameter -- suggests that historical data is available elsewhere
async function getGrandJSON (stationData) {
  let id = stationData.gaugeID,
      url = `https://apps.grandriver.ca/waterdata/kiwischarts/wiskiData/RF_Charts_UpperGrand/${id}.json`
  return await fetch(url)
    .then ( async (res) => {
      console.log(res.headers.get('Content-Type'))
      return res.json()
    })
    .then ( (json) => { console.log(json);return json[0].data} )
    .catch(function(error){console.log(error);});
}


async function getcvcJSON (stationData) {
  let id = stationData.gaugeID,
      baseUrl = 'https://waterinfo.cvc.ca/KiWIS/KiWIS?service=kisters&type=queryServices&request=getTimeseriesValues&datasource=0&format=dajson&',
      start = moment().subtract(4, 'days').format('YYYY-MM-DD'),
      end = moment().format('YYYY-MM-DD'),
      url = `${baseUrl}&ts_id=${id}&from=${start}&to=${end}&dateformat=UNIX`;
  console.log(url)
  return await fetch(url)
    .then ( async (res) => {
      console.log(res.headers.get('Content-Type'))
      return res.json()
    })
    .then ( (json) => { console.log(json);return json[0].data} )
    .catch(function(error){console.log(error);});
}

async function processWiskiData (spot) {
  const getter = spot.gaugeType === 'grca' ? getGrandJSON : getcvcJSON,
        raw = await getter(spot);
  // console.log ("MAP")
  return m = raw.map( (item) => {
    let meta = {};
    meta.height = Number(item[1]);
    meta.quality = testGood(item[1], spot);
    meta.units = spot.units;
    meta.data = item;
    //console.log('ITEM IS: ', item)
    // note: may need to adjust date for DST & time zone -- cf.
    // functions & comments in https://apps.grandriver.ca/waterdata/kiwischarts/js/RF_Charts.js?v1.0
    // lines ~43-65
    const itemObj = {x: new Date(item[0]),
                     y: item[1],
                     meta: meta
                    }
    return itemObj })
}



// let proxy = 'https://cors-anywhere.herokuapp.com/';
async function getWOJSON (stationData, needCors = true) {
  let start = moment().subtract(4, 'days').format('YYYY-MM-DD'),
      end = moment().format('YYYY-MM-DD'),
      headers = {Origin: "localhost"}
  params = `?param1=47&start_date=${start}&end_date=${end}&station=${stationData["gaugeID"]}`,
  cors = `http://localhost:9090/`; // `https://cors-anywhere.herokuapp.com/`
  let url = `https://wateroffice.ec.gc.ca/services/real_time_graph/json/inline${params}`;
  if (needCors) {url = `${cors}${url}`;}
  console.log(url);
  // let target = `${url}${params}`;
  return await fetch(url, {headers: headers})
    .then ( async (res) => {
      console.log(res.headers.get('Content-Type'))
      return res.json()
    })
    .then ( (json) => { console.log(json);return json["47"].provisional} )
    .catch(function(error){console.log(error);});
}



async function processWOData (spot=streetsville) {
  const raw = await getWOJSON(spot);
  return raw.map((item) => {
    let meta = {};
    meta.height = Number(item[1]);
    //console.log(item.wvd);
    //console.log ( item.wvd ? (item.wvd + 180)  : item.wdir )
    //console.log( (item.wvd ? "WVD: " : "WDIR: " ) + ( item.wvd ?  (item.wvd + 180) % 360 : item.wdir)  );
    meta.quality = testGood(item[1], spot);
    meta.units = spot.units;
    // item.quality = Math.trunc(item.quality);
    const itemObj =  { x: new Date(item[0]),
                       y: item[1],
                       // wvd: item.wvd,
                       // wdir: item.wdir,
                       // direction: (item.wvd ? ((item.wvd + 180) % 360) : item.wdir),
                       //direction: Math.trunc( (item.wvd ?  (item.wvd + 180) % 360 : item.wdir) ),
                       //meta: `<span class='arrow' style="--direction:${Math.trunc(item.wvd || item.wdir)}">&uarr;</span>`
                       meta: meta
                     };
    // console.log(itemObj);
    return itemObj
  })
}

async function processGauge (spot=irvine, mapper=gaugeDict) {
  console.log(spot.gaugeType, mapper[spot.gaugeType]);
  return await mapper[spot.gaugeType](spot);
}
#+end_src

#+RESULTS:

